import java.io.File
import java.util.Stack
import java.lang.Character.MIN_VALUE as nullChar
 
var level = 0
var dots = "........|........|........|........|........|........|........|"

sealed class Lexeme () {
       sealed class Keyword () : Lexeme () {
          data class SourceKW (val s: String) : Lexeme () 
	  data class MutableKW (val s: String) : Lexeme () 
	  data class PreviousKW (val s: String) : Lexeme () 
	  data class ParentsKW (val s: String) : Lexeme () 
	  data class DateKW (val s: String) : Lexeme () 
	  data class TicKW (val s: String) : Lexeme () 
       	  }
       data class Comment (val s: String) : Lexeme () {
       }
       data class Text (val s: String) : Lexeme () {	  
       }
}

fun functionName():String {
    val sta = Thread.currentThread().stackTrace[2]
    val str = sta.getMethodName()
    return str	
}

fun entering(here:String, caller:String):Unit {
    level = level + 1
    if (level > 70) {
       println ("Errot maximum number of nesting levels reached")
    } else {
        var points = dots.substring(0, level)
        println("$points Entering  in $here called by $caller")
    }
}

fun exiting(here:String):Unit {
    var points = dots.substring(0, level)
    println("$points Exiting from $here")
    level = level - 1	
}

fun read_input(caller:String):String {
    val here = functionName()
    entering(here, caller)
	
    val str = readLine().toString()
    exiting(here)
    return str
}

fun lineListOfFileName (nof: String) : MutableList<String> {

    val result = mutableListOf<String>()
 
    File(nof).useLines {
    	lines -> lines.forEach { result.add(it)}
	}

     return result
}

fun wordListOfString (str: String): List<String> {
    val trimedString = str.trim(' ')    

    val regex = Regex("\\s+")

    val result = trimedString.split(
	regex
    )
    return result
}

fun lineStackOfLineList (str_l: List<String>) : Stack<String> {
    var stack = Stack<String>()
    val rev_l = str_l.reversed().forEach { l -> stack.push(l) }
    return stack
}

fun wordStackOfLine (lin: String) : Stack<String> {
    var stack = Stack<String>()
    var wor_l = wordListOfString (lin)
    val rev_l = wor_l.reversed().forEach { w -> stack.push(w)}
    return stack
}

fun lexemeOfKeywordStack (wor_s:Stack<String> : Lexeme {

   var Done = false
   var currentWord = ""
   var nextWord = ""
   var threadfirstChar = ""
   val currentLexeme = Lexeme()
   
   while ( ! Done ) {
	try {
	    currentWord = wor_s.pop()
	    nextWord = wor_s.pop()

	    println("currentWord: '" + currentWord + "'")
	    println("nextWord: '" + nextWord + "'")

            threeFirstChar = currentWord.substr(0, 2)
	    println("threeFirstChar: '" + threeFirstChar + "'")
	    when (threeFirstChar) {
	      '$Da' -> currentLexeme =  DateKW (nextWord)
	      '$So' -> currentLexeme =  SourceKW (nextWord)
	      '$mu' -> currentLexeme =  MutableKW (nextWord)
	      '$pa' -> currentLexeme =  ParentsKW (nextWord)
	      '$pr' -> currentLexeme =  PreviousKW (nextWord)
	      '$ti' -> currentLexeme =  TicKW (nextWord)
		}
	      else -> {
	      	      val message = "Error unknown threeFirstChar: '" + threeFirstChar + "'"
    		      throw Exception(message)
}
	      }
    	   }
       	catch (e: java.util.EmptyStackException) {
       	     Done = true			
        }
    return currentLexeme
}

fun lexemeListOfSharpedLine (lin: String) : List<Lexeme> {
// # $Source: /my/perl/script/kwextract.pl,v$

   var Done = false
   var currentWord = ""
   var firstChar = nullChar
   var lexemeList = List<Lexeme>()
   var lex_l = List<Lexeme>()
   
   var wordStack = wordStackOfLine (lin)
   while ( ! Done ) {
	try {
	    currentWord = wordStack.pop()

	    println("currentWord: '" + currentWord + "'")

            firstChar = currentWord.get(0) 
	    println("firstChar: '" + firstChar + "'")
	    when (firstChar) {
	      '#' -> {println("skipped")}
	      '$' -> {
	          wordStack.push (currentWord)
	      	  lex_l = lexemeListOfKeywordStack (wordStack)
		  lexemeList.add (lex_l)
		}
	      else -> {
	      	      val message = "Error unknown firstChar: '" + firstChar + "'"
    		      throw Exception(message)
}
	      }
    	   }
       	catch (e: java.util.EmptyStackException) {
       	     Done = true			
        }

    }
    return lexemeList
}

fun lexemeListOfTextStack (stack: Stack<String>) : List<Lexeme> {

}

fun main(args: Array<String>) {
    val here = functionName()
    entering(here,"resolve")

    var firstChar = nullChar
    var Done = false
    var stackChar = Stack<Char>()
    var lineStack = Stack<String>()
    var currentLine = ""

//    println("Enter file name. Ex. 'current-block-test.yml'")
//    val fileName = read_input(here)
    val fileName = "t.yml"
    println("Entered file name : $fileName")

    println("Read the whole file as a List of String :")
    val lineList = lineListOfFileName (fileName)
    var lineStack = lineStackOfLineList (lineList)

    while ( ! Done ) {
	try {
	    currentLine = lineStack.pop()

	    println("currentLine: '" + currentLine + "'")

            firstChar = currentLine.get(0) 
	    println("firstChar: '" + firstChar + "'")
	    when (firstChar) {
	      '#' -> lexemeListOfSharpedLine (currentLine)
	      ' ' -> {
	        lineStack.push (currentLine)
	      	lexemeListOfTextStack (lineStack)
		}
    	      }
	
	}
       	catch (e: java.util.EmptyStackException) {
       	     Done = true			
        }

    }
	 
    exiting(here)
}

